{"version":3,"file":"WebSocketTransport.js","sourceRoot":"","sources":["../../src/WebSocketTransport.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { MessageHeaders } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { ITransport, TransferFormat } from \"./ITransport\";\r\nimport { WebSocketConstructor } from \"./Polyfills\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, Platform } from \"./Utils\";\r\n\r\n/** @private */\r\nexport class WebSocketTransport implements ITransport {\r\n    private readonly logger: ILogger;\r\n    private readonly accessTokenFactory: (() => string | Promise<string>) | undefined;\r\n    private readonly logMessageContent: boolean;\r\n    private readonly webSocketConstructor: WebSocketConstructor;\r\n    private readonly httpClient: HttpClient;\r\n    private webSocket?: WebSocket;\r\n    private headers: MessageHeaders;\r\n\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((error?: Error) => void) | null;\r\n\r\n    constructor(httpClient: HttpClient, accessTokenFactory: (() => string | Promise<string>) | undefined, logger: ILogger,\r\n                logMessageContent: boolean, webSocketConstructor: WebSocketConstructor, headers: MessageHeaders) {\r\n        this.logger = logger;\r\n        this.accessTokenFactory = accessTokenFactory;\r\n        this.logMessageContent = logMessageContent;\r\n        this.webSocketConstructor = webSocketConstructor;\r\n        this.httpClient = httpClient;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n        this.headers = headers;\r\n    }\r\n\r\n    public async connect(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this.logger.log(LogLevel.Trace, \"(WebSockets transport) Connecting.\");\r\n\r\n        if (this.accessTokenFactory) {\r\n            const token = await this.accessTokenFactory();\r\n            if (token) {\r\n                url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\r\n            }\r\n        }\r\n\r\n        return new Promise<void>((resolve, reject) => {\r\n            url = url.replace(/^http/, \"ws\");\r\n            let webSocket: WebSocket | undefined;\r\n            const cookies = this.httpClient.getCookieString(url);\r\n            let opened = false;\r\n\r\n            if (Platform.isNode) {\r\n                const headers = {};\r\n                const [name, value] = getUserAgentHeader();\r\n                headers[name] = value;\r\n\r\n                if (cookies) {\r\n                    headers[`Cookie`] = `${cookies}`;\r\n                }\r\n\r\n                // Only pass headers when in non-browser environments\r\n                webSocket = new this.webSocketConstructor(url, undefined, {\r\n                    headers: { ...headers, ...this.headers },\r\n                });\r\n            }\r\n\r\n            if (!webSocket) {\r\n                // Chrome is not happy with passing 'undefined' as protocol\r\n                webSocket = new this.webSocketConstructor(url);\r\n            }\r\n\r\n            if (transferFormat === TransferFormat.Binary) {\r\n                webSocket.binaryType = \"arraybuffer\";\r\n            }\r\n\r\n            // tslint:disable-next-line:variable-name\r\n            webSocket.onopen = (_event: Event) => {\r\n                this.logger.log(LogLevel.Information, `WebSocket connected to ${url}.`);\r\n                this.webSocket = webSocket;\r\n                opened = true;\r\n                resolve();\r\n            };\r\n\r\n            webSocket.onerror = (event: Event) => {\r\n                let error: any = null;\r\n                // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                    error = event.error;\r\n                } else {\r\n                    error = new Error(\"There was an error with the transport.\");\r\n                }\r\n\r\n                reject(error);\r\n            };\r\n\r\n            webSocket.onmessage = (message: MessageEvent) => {\r\n                this.logger.log(LogLevel.Trace, `(WebSockets transport) data received. ${getDataDetail(message.data, this.logMessageContent)}.`);\r\n                if (this.onreceive) {\r\n                    try {\r\n                        this.onreceive(message.data);\r\n                    } catch (error) {\r\n                        this.close(error);\r\n                        return;\r\n                    }\r\n                }\r\n            };\r\n\r\n            webSocket.onclose = (event: CloseEvent) => {\r\n                // Don't call close handler if connection was never established\r\n                // We'll reject the connect call instead\r\n                if (opened) {\r\n                    this.close(event);\r\n                } else {\r\n                    let error: any = null;\r\n                    // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                    if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                        error = event.error;\r\n                    } else {\r\n                        error = new Error(\"There was an error with the transport.\");\r\n                    }\r\n\r\n                    reject(error);\r\n                }\r\n            };\r\n        });\r\n    }\r\n\r\n    public send(data: any): Promise<void> {\r\n        if (this.webSocket && this.webSocket.readyState === this.webSocketConstructor.OPEN) {\r\n            this.logger.log(LogLevel.Trace, `(WebSockets transport) sending data. ${getDataDetail(data, this.logMessageContent)}.`);\r\n            this.webSocket.send(data);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        return Promise.reject(\"WebSocket is not in the OPEN state\");\r\n    }\r\n\r\n    public stop(): Promise<void> {\r\n        if (this.webSocket) {\r\n            // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning\r\n            // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects\r\n            this.close(undefined);\r\n        }\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private close(event?: CloseEvent | Error): void {\r\n        // webSocket will be null if the transport did not start successfully\r\n        if (this.webSocket) {\r\n            // Clear websocket handlers because we are considering the socket closed now\r\n            this.webSocket.onclose = () => {};\r\n            this.webSocket.onmessage = () => {};\r\n            this.webSocket.onerror = () => {};\r\n            this.webSocket.close();\r\n            this.webSocket = undefined;\r\n        }\r\n\r\n        this.logger.log(LogLevel.Trace, \"(WebSockets transport) socket closed.\");\r\n        if (this.onclose) {\r\n            if (this.isCloseEvent(event) && (event.wasClean === false || event.code !== 1000)) {\r\n                this.onclose(new Error(`WebSocket closed with status code: ${event.code} (${event.reason}).`));\r\n            } else if (event instanceof Error) {\r\n                this.onclose(event);\r\n            } else {\r\n                this.onclose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private isCloseEvent(event?: any): event is CloseEvent {\r\n        return event && typeof event.wasClean === \"boolean\" && typeof event.code === \"number\";\r\n    }\r\n}\r\n"]}